package org.folio.rest.impl;

import java.util.HashMap;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;
import org.folio.rest.RestVerticle;
import org.folio.rest.annotations.Validate;
import org.folio.rest.jaxrs.model.PoLine;
import org.folio.rest.jaxrs.model.CompositePurchaseOrder;
import org.folio.rest.jaxrs.resource.Orders;
import org.folio.rest.tools.client.HttpClientFactory;
import org.folio.rest.tools.client.interfaces.HttpClientInterface;
import org.folio.rest.tools.utils.TenantTool;

import io.vertx.core.AsyncResult;
import io.vertx.core.Context;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.core.http.HttpHeaders;
import io.vertx.core.json.JsonObject;
import io.vertx.core.logging.Logger;
import io.vertx.core.logging.LoggerFactory;

import javax.ws.rs.core.Response;

public class OrdersImpl implements Orders {

  private static final Logger logger = LoggerFactory.getLogger(OrdersImpl.class);

  public static final String OKAPI_HEADER_URL = "X-Okapi-Url";
  private static final String ORDERS_LOCATION_PREFIX = "/orders/";
  private static final String ORDER_LINE_LOCATION_PREFIX = "/orders/%s/lines/%s";

  @Override
  @Validate
  public void deleteOrdersById(String id, String lang, Map<String, String> okapiHeaders,
      Handler<AsyncResult<javax.ws.rs.core.Response>> asyncResultHandler, Context vertxContext) {
    final HttpClientInterface httpClient = getHttpClient(okapiHeaders);

    //to handle delete API's content-type text/plain
    Map<String,String> customHeader=new HashMap<>();
    customHeader.put(HttpHeaders.ACCEPT.toString(), "application/json, text/plain");
    httpClient.setDefaultHeaders(customHeader);

    DeleteOrdersByIdHelper helper = new DeleteOrdersByIdHelper(httpClient, okapiHeaders, asyncResultHandler, vertxContext);
    helper.deleteOrder(id,lang)
    .thenRun(()->{
      logger.info("Successfully deleted order: ");
      httpClient.closeClient();
      javax.ws.rs.core.Response response = DeleteOrdersByIdResponse.respond204();
      AsyncResult<javax.ws.rs.core.Response> result = Future.succeededFuture(response);
      asyncResultHandler.handle(result);
    })
    .exceptionally(helper::handleError);
  }

  @Override
  @Validate
  public void getOrdersById(String id, String lang, Map<String, String> okapiHeaders,
      Handler<AsyncResult<javax.ws.rs.core.Response>> asyncResultHandler, Context vertxContext) {

    final HttpClientInterface httpClient = getHttpClient(okapiHeaders);
    GetOrdersByIdHelper helper = new GetOrdersByIdHelper(httpClient, okapiHeaders, asyncResultHandler, vertxContext);

    helper.getOrder(id, lang)
      .thenAccept(order -> {
        logger.info("Successfully retrieved order: " + JsonObject.mapFrom(order).encodePrettily());
        httpClient.closeClient();
        javax.ws.rs.core.Response response = GetOrdersByIdResponse.respond200WithApplicationJson(order);
        AsyncResult<javax.ws.rs.core.Response> result = Future.succeededFuture(response);
        asyncResultHandler.handle(result);
      })
      .exceptionally(helper::handleError);
  }

  @Override
  @Validate
  public void postOrders(String lang, CompositePurchaseOrder compPO, Map<String, String> okapiHeaders,
      Handler<AsyncResult<javax.ws.rs.core.Response>> asyncResultHandler, Context vertxContext) {

    final HttpClientInterface httpClient = getHttpClient(okapiHeaders);
    PostOrdersHelper helper = new PostOrdersHelper(httpClient, okapiHeaders, asyncResultHandler, vertxContext);

    logger.info("Creating PO and POLines...");
    helper.createPOandPOLinesWithAutoGeneratedData(compPO)
      .thenAccept(withIds -> {

        logger.info("Applying Funds...");
        helper.applyFunds(withIds)
          .thenAccept(withFunds -> {

            logger.info("Updating Inventory...");
            helper.updateInventory(withFunds)
              .thenAccept(withInventory -> {

                logger.info("Successfully Placed Order: " + JsonObject.mapFrom(withInventory).encodePrettily());
                httpClient.closeClient();
                javax.ws.rs.core.Response response = PostOrdersResponse.respond201WithApplicationJson(withInventory,
                  PostOrdersResponse.headersFor201().withLocation(ORDERS_LOCATION_PREFIX + withInventory.getId()));
                AsyncResult<javax.ws.rs.core.Response> result = Future.succeededFuture(response);
                asyncResultHandler.handle(result);
              })
              .exceptionally(helper::handleError);
          })
          .exceptionally(helper::handleError);
      })
      .exceptionally(helper::handleError);
  }

  @Override
  @Validate
  public void putOrdersById(String id, String lang, CompositePurchaseOrder compPO, Map<String, String> okapiHeaders,
      Handler<AsyncResult<javax.ws.rs.core.Response>> asyncResultHandler, Context vertxContext) {
        final HttpClientInterface httpClient = getHttpClient(okapiHeaders);
        PutOrdersByIdHelper putHelper = new PutOrdersByIdHelper(httpClient, okapiHeaders, asyncResultHandler, vertxContext);
       putHelper.updateOrder(id, lang, compPO, vertxContext)
         .exceptionally(putHelper::handleError);
  }

  @Override
  @Validate
  public void postOrdersLinesById(String orderId, String lang, PoLine poLine, Map<String, String> okapiHeaders,
                                  Handler<AsyncResult<javax.ws.rs.core.Response>> asyncResultHandler, Context vertxContext) {
    final HttpClientInterface httpClient = getHttpClient(okapiHeaders);
    PostOrdersHelper helper = new PostOrdersHelper(httpClient, okapiHeaders, asyncResultHandler, vertxContext);

    logger.info("Creating POLine to an existing order...");

    if (poLine.getPurchaseOrderId() == null) {
      logger.info("POLine without id. Set id from path url: " + orderId);
      poLine.setPurchaseOrderId(orderId);
    }

    if (orderId.equals(poLine.getPurchaseOrderId())) {
      helper.createPoLine(poLine)
        .thenAccept(pol -> {
          logger.info("Successfully added PO Line: " + JsonObject.mapFrom(pol).encodePrettily());
          httpClient.closeClient();
          Response response = PostOrdersLinesByIdResponse.respond201WithApplicationJson(poLine,
            PostOrdersLinesByIdResponse.headersFor201()
                                       .withLocation(String.format(ORDER_LINE_LOCATION_PREFIX, orderId, pol.getId())));
          AsyncResult<javax.ws.rs.core.Response> result = Future.succeededFuture(response);
          asyncResultHandler.handle(result);
        })
        .exceptionally(helper::handleError);
    } else {
      asyncResultHandler
        .handle(Future.succeededFuture(PostOrdersLinesByIdResponse.respond400WithTextPlain("Mismatch between id in path and POLine")));
    }
  }

  @Override
  @Validate
  public void getOrdersLinesByIdAndLineId(String id, String lineId, String lang, Map<String, String> okapiHeaders,
                                          Handler<AsyncResult<javax.ws.rs.core.Response>> asyncResultHandler, Context vertxContext) {

    logger.info("Started Invocation of POLine Request with id = " + lineId);
    final HttpClientInterface httpClient = getHttpClient(okapiHeaders);
    GetPOLineByIdHelper helper = new GetPOLineByIdHelper(httpClient, okapiHeaders, asyncResultHandler, vertxContext);

    helper.getPOLineByPOLineId(id, lineId, lang)
      .thenAccept(poline -> {
        logger.info("Received POLine Response: " + JsonObject.mapFrom(poline).encodePrettily());
        httpClient.closeClient();
        javax.ws.rs.core.Response response = GetOrdersLinesByIdAndLineIdResponse.respond200WithApplicationJson(poline);
        AsyncResult<javax.ws.rs.core.Response> result = Future.succeededFuture(response);
        asyncResultHandler.handle(result);
      })
      .exceptionally(helper::handleError);
  }

  @Override
  @Validate
  public void deleteOrdersLinesByIdAndLineId(String orderId, String lineId, String lang, Map<String, String> okapiHeaders,
                                             Handler<AsyncResult<javax.ws.rs.core.Response>> asyncResultHandler, Context vertxContext) {
    new DeleteOrderLineByIdHelper(okapiHeaders, asyncResultHandler, vertxContext)
      .deleteLine(orderId, lineId, lang);
  }

  @Override
  @Validate
  public void putOrdersLinesByIdAndLineId(String orderId, String lineId, String lang, PoLine poLine, Map<String, String> okapiHeaders,
                                            Handler<AsyncResult<javax.ws.rs.core.Response>> asyncResultHandler, Context vertxContext) {
    logger.info("Handling PUT Order Line operation...");

    PutOrderLineByIdHelper helper = new PutOrderLineByIdHelper(okapiHeaders, asyncResultHandler, vertxContext);
    if (StringUtils.isEmpty(poLine.getPurchaseOrderId())) {
      poLine.setPurchaseOrderId(orderId);
    }
    if (StringUtils.isEmpty(poLine.getId())) {
      poLine.setId(lineId);
    }
    if (orderId.equals(poLine.getPurchaseOrderId()) && lineId.equals(poLine.getId())) {
      helper
        .updateOrder(orderId, lang, poLine);
    } else {
      asyncResultHandler
        .handle(Future.succeededFuture(helper.buildErrorResponse(422, "Mismatch between id in path and PoLine")));
    }
  }

  public static HttpClientInterface getHttpClient(Map<String, String> okapiHeaders) {
    final String okapiURL = okapiHeaders.getOrDefault(OKAPI_HEADER_URL, "");
    final String tenantId = TenantTool.calculateTenantId(okapiHeaders.get(RestVerticle.OKAPI_HEADER_TENANT));

    return HttpClientFactory.getHttpClient(okapiURL, tenantId);
  }

}

